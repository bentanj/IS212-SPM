'use client';

import React, { useState, useEffect, useMemo } from 'react';
import {
  Card,
  CardContent,
  CardActions,
  Container,
  Typography,
  Button,
  Chip,
  Paper,
  Alert,
  Stack,
} from '@mui/material';
import {
  TrendingUp,
  People,
  CheckCircle,
  PictureAsPdf,
  TableChart,
  Timer,
} from '@mui/icons-material';
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import { Chart, ChartConfiguration, registerables } from 'chart.js';
import ChartDataLabels from 'chartjs-plugin-datalabels';
import html2canvas from 'html2canvas';
import { taskMockData } from '@/mocks/staff/taskMockData';

// Register Chart.js components
Chart.register(...registerables, ChartDataLabels);

interface ReportType {
  id: string;
  title: string;
  description: string;
  icon: React.ReactNode;
  category: string;
  estimatedTime: string;
  dataPoints: number;
}

export default function ReportGeneration() {
  const [selectedReport, setSelectedReport] = useState<string | null>(null);
  const [exportType, setExportType] = useState<'pdf' | 'excel' | null>(null);
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  const currentDate = useMemo(() => new Date().toLocaleDateString(), []);

  // Calculate data points from mock data
  const totalTasks = taskMockData.tasks.length;
  const completedTasks = taskMockData.tasks.filter(
    (task) => task.status === 'Completed'
  ).length;
  const inProgressTasks = taskMockData.tasks.filter(
    (task) => task.status === 'In Progress'
  ).length;
  const blockedTasks = taskMockData.tasks.filter(
    (task) => task.status === 'Blocked'
  ).length;
  const toDoTasks = taskMockData.tasks.filter(
    (task) => task.status === 'To Do'
  ).length;
  const uniqueProjects = new Set(
    taskMockData.tasks.map((task) => task.projectName)
  ).size;
  const uniqueDepartments = new Set(
    taskMockData.tasks.flatMap((task) =>
      task.assignedUsers.map((user) => user.department)
    )
  ).size;

  // Helper function to create chart and return image
  const createChartImageFromDiv = async (
    chartConfig: ChartConfiguration,
    width: number = 500,
    height: number = 500
  ): Promise<string> => {
    return new Promise((resolve, reject) => {
      // Create temporary container
      const tempDiv = document.createElement('div');
      tempDiv.style.position = 'fixed';
      tempDiv.style.left = '-9999px';
      tempDiv.style.top = '0';
      tempDiv.style.width = `${width}px`;
      tempDiv.style.height = `${height}px`;
      tempDiv.style.backgroundColor = '#ffffff';
      tempDiv.style.padding = '20px';
      
      // Create canvas
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      tempDiv.appendChild(canvas);
      
      // Append to body
      document.body.appendChild(tempDiv);
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        document.body.removeChild(tempDiv);
        reject('Could not get canvas context');
        return;
      }
      
      // Create chart
      const chart = new Chart(ctx, chartConfig);
      
      // Wait for animation and render
      setTimeout(async () => {
        try {
          // Use html2canvas to capture the div
          const capturedCanvas = await html2canvas(tempDiv, {
            backgroundColor: '#ffffff',
            scale: 2,
            logging: false,
          });
          
          const imageData = capturedCanvas.toDataURL('image/png', 1.0);
          
          // Cleanup
          chart.destroy();
          document.body.removeChild(tempDiv);
          
          resolve(imageData);
        } catch (error) {
          chart.destroy();
          document.body.removeChild(tempDiv);
          reject(error);
        }
      }, 1000);
    });
  };

  // PDF Export Functions
  const generateTaskCompletionPDF = async () => {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    let yPos = 20;

    // Header
    doc.setFontSize(22);
    doc.setFont('helvetica', 'bold');
    doc.text('Task Completion/Status Report', pageWidth / 2, yPos, { align: 'center' });

    yPos += 10;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated: ${currentDate}`, pageWidth / 2, yPos, { align: 'center' });
    doc.text(`Generated by: ${taskMockData.currentUser.name} (${taskMockData.currentUser.role})`, pageWidth / 2, yPos + 5, { align: 'center' });

    yPos += 20;

    // Summary Statistics
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Summary Statistics', 14, yPos);
    yPos += 10;

    const stats = [
      ['Total Tasks', totalTasks.toString()],
      ['Completed Tasks', `${completedTasks} (${((completedTasks / totalTasks) * 100).toFixed(1)}%)`],
      ['In Progress Tasks', `${inProgressTasks} (${((inProgressTasks / totalTasks) * 100).toFixed(1)}%)`],
      ['Blocked Tasks', `${blockedTasks} (${((blockedTasks / totalTasks) * 100).toFixed(1)}%)`],
      ['To Do Tasks', `${toDoTasks} (${((toDoTasks / totalTasks) * 100).toFixed(1)}%)`],
      ['Active Projects', uniqueProjects.toString()],
      ['Departments', uniqueDepartments.toString()],
    ];

    autoTable(doc, {
      startY: yPos,
      head: [['Metric', 'Value']],
      body: stats,
      theme: 'grid',
      headStyles: { fillColor: [102, 126, 234], fontSize: 11 },
      styles: { fontSize: 10 },
      margin: { left: 14, right: 14 },
    });

    yPos = (doc as any).lastAutoTable.finalY + 15;

    // Create Status Distribution Chart
    const chartConfig: ChartConfiguration = {
      type: 'pie',
      data: {
        labels: ['Completed', 'In Progress', 'To Do', 'Blocked'],
        datasets: [{
          data: [completedTasks, inProgressTasks, toDoTasks, blockedTasks],
          backgroundColor: [
            '#4CAF50',
            '#2196F3',
            '#FFC107',
            '#F44336',
          ],
          borderColor: '#ffffff',
          borderWidth: 2,
          borderAlign: 'center',
        }],
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        animation: {
          duration: 0,
        },
        plugins: {
          legend: {
            position: 'bottom',
            labels: {
              font: { size: 16 },
              padding: 20,
              boxWidth: 20,
            },
          },
          title: {
            display: true,
            text: 'Task Status Distribution',
            font: { size: 20, weight: 'bold' },
            padding: { bottom: 20 },
          },
          datalabels: {
            color: '#ffffff',
            font: {
              weight: 'bold',
              size: 18,
            },
            formatter: (value: number, context: any) => {
              const dataset = context.chart.data.datasets[0];
              const total = dataset.data.reduce((acc: number, curr: number) => acc + curr, 0);
              const percentage = ((value / total) * 100).toFixed(1);
              return `${percentage}%`;
            },
          },
        },
      },
    };

    try {
      const chartImage = await createChartImageFromDiv(chartConfig, 500, 500);
      
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Task Status Distribution', 14, yPos);
      yPos += 10;

      doc.addImage(chartImage, 'PNG', 50, yPos, 110, 110);
      yPos += 120;

    } catch (error) {
      console.error('Error creating chart:', error);
      doc.setFontSize(10);
      doc.text('Chart generation failed', 14, yPos);
      yPos += 10;
    }

    // Add new page for task details
    doc.addPage();
    yPos = 20;

    // Task Details by Status
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Task Details', 14, yPos);
    yPos += 10;

    const taskData = taskMockData.tasks.map((task) => [
      task.title.length > 30 ? task.title.substring(0, 30) + '...' : task.title,
      task.status,
      task.priority,
      task.projectName.length > 20 ? task.projectName.substring(0, 20) + '...' : task.projectName,
      task.assignedUsers.length > 0 ? task.assignedUsers[0].name : 'Unassigned',
      task.completedDate || 'N/A',
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Task Title', 'Status', 'Priority', 'Project', 'Assignee', 'Completed']],
      body: taskData,
      theme: 'striped',
      headStyles: { fillColor: [102, 126, 234], fontSize: 9 },
      styles: { fontSize: 8, cellPadding: 3 },
      columnStyles: {
        0: { cellWidth: 50 },
        1: { cellWidth: 25 },
        2: { cellWidth: 20 },
        3: { cellWidth: 35 },
        4: { cellWidth: 30 },
        5: { cellWidth: 25 },
      },
      margin: { left: 14, right: 14 },
    });

    // Save PDF
    doc.save(`Task-Completion-Report-${Date.now()}.pdf`);
  };

  const generateProjectPerformancePDF = async () => {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    let yPos = 20;

    doc.setFontSize(22);
    doc.setFont('helvetica', 'bold');
    doc.text('Project Performance Analytics', pageWidth / 2, yPos, { align: 'center' });

    yPos += 10;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated: ${currentDate}`, pageWidth / 2, yPos, { align: 'center' });

    yPos += 20;

    // Group tasks by project
    const projectMap = new Map<string, any[]>();
    taskMockData.tasks.forEach((task) => {
      if (!projectMap.has(task.projectName)) {
        projectMap.set(task.projectName, []);
      }
      projectMap.get(task.projectName)!.push(task);
    });

    const projectData = Array.from(projectMap.entries()).map(([projectName, tasks]) => {
      const completed = tasks.filter((t) => t.status === 'Completed').length;
      const inProgress = tasks.filter((t) => t.status === 'In Progress').length;
      const toDo = tasks.filter((t) => t.status === 'To Do').length;
      const blocked = tasks.filter((t) => t.status === 'Blocked').length;
      const completionRate = ((completed / tasks.length) * 100).toFixed(1);

      return {
        name: projectName,
        total: tasks.length,
        completed,
        inProgress,
        toDo,
        blocked,
        rate: parseFloat(completionRate),
      };
    });

    // Sort by total tasks (descending) to show most active projects first
    projectData.sort((a, b) => b.total - a.total);

    // Create Horizontal Stacked Bar Chart
    const chartConfig: ChartConfiguration = {
      type: 'bar',
      data: {
        labels: projectData.map((p) => {
          // Truncate long project names
          const name = p.name.length > 25 ? p.name.substring(0, 25) + '...' : p.name;
          return name;
        }),
        datasets: [
          {
            label: 'Completed',
            data: projectData.map((p) => p.completed),
            backgroundColor: '#4CAF50',
            borderColor: '#4CAF50',
            borderWidth: 1,
          },
          {
            label: 'In Progress',
            data: projectData.map((p) => p.inProgress),
            backgroundColor: '#2196F3',
            borderColor: '#2196F3',
            borderWidth: 1,
          },
          {
            label: 'To Do',
            data: projectData.map((p) => p.toDo),
            backgroundColor: '#FFC107',
            borderColor: '#FFC107',
            borderWidth: 1,
          },
          {
            label: 'Blocked',
            data: projectData.map((p) => p.blocked),
            backgroundColor: '#F44336',
            borderColor: '#F44336',
            borderWidth: 1,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        indexAxis: 'y', // THIS MAKES IT HORIZONTAL
        animation: {
          duration: 0,
        },
        scales: {
          x: {
            stacked: true, // ENABLE STACKING
            beginAtZero: true,
            ticks: {
              stepSize: 1,
              font: {
                size: 11,
              },
            },
            grid: {
              display: true,
            },
          },
          y: {
            stacked: true, // ENABLE STACKING
            ticks: {
              font: {
                size: 10,
              },
            },
            grid: {
              display: false,
            },
          },
        },
        plugins: {
          legend: {
            position: 'top',
            labels: {
              font: { size: 12 },
              padding: 10,
              boxWidth: 15,
            },
          },
          title: {
            display: true,
            text: 'Project Task Status Distribution',
            font: { size: 16, weight: 'bold' },
            padding: { bottom: 15 },
          },
          tooltip: {
            mode: 'index',
            intersect: false,
            callbacks: {
              footer: (tooltipItems: any) => {
                let total = 0;
                tooltipItems.forEach((item: any) => {
                  total += item.parsed.x;
                });
                return `Total: ${total} tasks`;
              },
            },
          },
          datalabels: {
            display: true,
            color: '#ffffff',
            font: {
              weight: 'bold',
              size: 10,
            },
            formatter: (value: number) => {
              // Only show label if value > 0
              return value > 0 ? value : '';
            },
          },
        },
      },
    };

    try {
      // Adjust height based on number of projects (more projects = taller chart)
      const chartHeight = Math.max(400, projectData.length * 40);
      const chartImage = await createChartImageFromDiv(chartConfig, 700, chartHeight);

      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Project Performance Overview', 14, yPos);
      yPos += 10;

      // Calculate appropriate image dimensions for PDF
      const imageWidth = 180;
      const imageHeight = (chartHeight / 700) * imageWidth;

      doc.addImage(chartImage, 'PNG', 15, yPos, imageWidth, Math.min(imageHeight, 150));
      yPos += Math.min(imageHeight, 150) + 10;

    } catch (error) {
      console.error('Error creating chart:', error);
    }

    // Add new page if needed
    if (yPos > 200) {
      doc.addPage();
      yPos = 20;
    }

    // Project Statistics Table
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Detailed Project Statistics', 14, yPos);
    yPos += 10;

    const tableData = projectData.map((p) => [
      p.name,
      p.total.toString(),
      p.completed.toString(),
      p.inProgress.toString(),
      p.toDo.toString(),
      p.blocked.toString(),
      `${p.rate}%`,
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Project Name', 'Total', 'Completed', 'In Progress', 'To Do', 'Blocked', 'Rate']],
      body: tableData,
      theme: 'grid',
      headStyles: { 
        fillColor: [76, 175, 80], 
        fontSize: 9,
        fontStyle: 'bold',
      },
      styles: { 
        fontSize: 8, 
        halign: 'center',
        cellPadding: 2,
      },
      columnStyles: {
        0: { halign: 'left', cellWidth: 60 },
        1: { cellWidth: 15 },
        2: { cellWidth: 20, fillColor: [232, 245, 233] },
        3: { cellWidth: 22, fillColor: [227, 242, 253] },
        4: { cellWidth: 15, fillColor: [255, 248, 225] },
        5: { cellWidth: 17, fillColor: [255, 235, 238] },
        6: { cellWidth: 18, fontStyle: 'bold' },
      },
      margin: { left: 14, right: 14 },
    });

    doc.save(`Project-Performance-Report-${Date.now()}.pdf`);
  };


  const generateTeamProductivityPDF = async () => {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    let yPos = 20;

    doc.setFontSize(22);
    doc.setFont('helvetica', 'bold');
    doc.text('Team Productivity Report', pageWidth / 2, yPos, { align: 'center' });

    yPos += 10;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated: ${currentDate}`, pageWidth / 2, yPos, { align: 'center' });

    yPos += 20;

    // Group tasks by user
    const userTaskMap = new Map<string, any[]>();
    taskMockData.tasks.forEach((task) => {
      task.assignedUsers.forEach((user) => {
        if (!userTaskMap.has(user.name)) {
          userTaskMap.set(user.name, []);
        }
        userTaskMap.get(user.name)!.push(task);
      });
    });

    const userData = Array.from(userTaskMap.entries()).map(([userName, tasks]) => {
      const completed = tasks.filter((t) => t.status === 'Completed').length;
      const inProgress = tasks.filter((t) => t.status === 'In Progress').length;
      const userInfo = taskMockData.tasks
        .flatMap((t) => t.assignedUsers)
        .find((u) => u.name === userName);

      return {
        name: userName,
        department: userInfo?.department || 'N/A',
        role: userInfo?.role || 'N/A',
        total: tasks.length,
        completed,
        inProgress,
        rate: ((completed / tasks.length) * 100).toFixed(1),
      };
    });

    // Create Team Productivity Chart
    const topUsers = userData.slice(0, 10);

    const chartConfig: ChartConfiguration = {
      type: 'bar',
      data: {
        labels: topUsers.map((u) => u.name.length > 12 ? u.name.substring(0, 12) + '...' : u.name),
        datasets: [{
          label: 'Completion Rate (%)',
          data: topUsers.map((u) => parseFloat(u.rate)),
          backgroundColor: '#2196F3',
          borderColor: '#2196F3',
          borderWidth: 2,
        }],
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        animation: {
          duration: 0,
        },
        indexAxis: 'y',
        scales: {
          x: {
            beginAtZero: true,
            max: 100,
            ticks: {
              callback: function(value) {
                return value + '%';
              },
            },
          },
        },
        plugins: {
          legend: {
            display: false,
          },
          title: {
            display: true,
            text: 'Top 10 Team Members by Completion Rate',
            font: { size: 16, weight: 'bold' },
          },
          datalabels: {
            display: false,
          },
        },
      },
    };

    try {
      const chartImage = await createChartImageFromDiv(chartConfig, 600, 400);

      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Team Productivity Visualization', 14, yPos);
      yPos += 10;

      doc.addImage(chartImage, 'PNG', 20, yPos, 170, 120);
      yPos += 130;

    } catch (error) {
      console.error('Error creating chart:', error);
    }

    // Add new page for detailed table
    if (yPos > 200) {
      doc.addPage();
      yPos = 20;
    }

    const tableData = userData.map((u) => [
      u.name,
      u.department,
      u.role,
      u.total.toString(),
      u.completed.toString(),
      u.inProgress.toString(),
      u.rate + '%',
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Team Member', 'Department', 'Role', 'Total Tasks', 'Completed', 'In Progress', 'Completion Rate']],
      body: tableData,
      theme: 'striped',
      headStyles: { fillColor: [33, 150, 243], fontSize: 9 },
      styles: { fontSize: 8 },
      margin: { left: 14, right: 14 },
    });

    doc.save(`Team-Productivity-Report-${Date.now()}.pdf`);
  };

  const reportTypes: ReportType[] = [
    {
      id: 'task-completion-status',
      title: 'Task Completion/Status Report',
      description:
        'Comprehensive overview of task completion rates, status distribution, and progress tracking across all projects. Includes breakdown by priority, department, and timeline analysis.',
      icon: <CheckCircle sx={{ fontSize: 40, color: 'primary.main' }} />,
      category: 'Task Management',
      estimatedTime: '2-3 minutes',
      dataPoints: totalTasks,
    },
    {
      id: 'project-performance',
      title: 'Project Performance Analytics',
      description:
        'Detailed analysis of project performance metrics including task distribution, completion rates, team efficiency, and milestone tracking. Provides insights into project health and bottlenecks.',
      icon: <TrendingUp sx={{ fontSize: 40, color: 'success.main' }} />,
      category: 'Project Analytics',
      estimatedTime: '3-4 minutes',
      dataPoints: uniqueProjects,
    },
    {
      id: 'team-productivity',
      title: 'Team Productivity Report',
      description:
        'In-depth productivity analysis covering individual and team performance, workload distribution, task assignment patterns, and collaboration metrics across departments.',
      icon: <People sx={{ fontSize: 40, color: 'info.main' }} />,
      category: 'Team Analytics',
      estimatedTime: '2-3 minutes',
      dataPoints: taskMockData.tasks.flatMap((task) => task.assignedUsers).length,
    },
  ];

  const handleExportReport = async (reportId: string, type: 'pdf' | 'excel') => {
    setSelectedReport(reportId);
    setExportType(type);

    await new Promise((resolve) => setTimeout(resolve, 800));

    if (type === 'pdf') {
      switch (reportId) {
        case 'task-completion-status':
          await generateTaskCompletionPDF();
          break;
        case 'project-performance':
          await generateProjectPerformancePDF();
          break;
        case 'team-productivity':
          await generateTeamProductivityPDF();
          break;
      }
    } else {
      console.log('Excel export for:', reportId);
      alert('Excel export will be implemented next!');
    }

    setSelectedReport(null);
    setExportType(null);
  };

  const getCategoryColor = (category: string) => {
    const colors: { [key: string]: string } = {
      'Task Management': 'primary',
      'Project Analytics': 'success',
      'Team Analytics': 'info',
    };
    return colors[category] || 'default';
  };

  if (!mounted) {
    return null;
  }

  return (
    <div style={{ backgroundColor: '#ffffff', minHeight: '100vh' }} suppressHydrationWarning>
      <Container maxWidth="lg" sx={{ py: { xs: 2, sm: 3, md: 4 } }}>
        {/* Header Section */}
        <Paper
          elevation={0}
          sx={{
            p: { xs: 2, sm: 3, md: 4 },
            mb: { xs: 2, sm: 3, md: 4 },
            background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            color: 'white',
            borderRadius: 2,
          }}
        >
          <Typography
            variant="h3"
            component="h1"
            gutterBottom
            fontWeight={600}
            sx={{
              fontSize: { xs: '1.75rem', sm: '2.5rem', md: '3rem' },
            }}
          >
            Reports Dashboard
          </Typography>
          <Typography
            variant="h6"
            sx={{
              opacity: 0.9,
              mb: { xs: 1, sm: 2 },
              fontSize: { xs: '1rem', sm: '1.15rem', md: '1.25rem' },
            }}
          >
            Welcome, {taskMockData.currentUser.name} ({taskMockData.currentUser.role})
          </Typography>
          <Typography
            variant="body1"
            sx={{
              opacity: 0.85,
              fontSize: { xs: '0.875rem', sm: '1rem' },
            }}
          >
            Generate comprehensive reports and analytics to gain insights into task management,
            team performance, and organizational productivity.
          </Typography>
        </Paper>

        {selectedReport && exportType && (
          <Alert severity="success" sx={{ mb: { xs: 2, sm: 3 } }}>
            Exporting to {exportType === 'pdf' ? 'PDF' : 'Excel'}... This may take a few moments.
          </Alert>
        )}

        {/* Reports Section */}
        <Typography
          variant="h5"
          fontWeight={600}
          sx={{
            mb: { xs: 2, sm: 3 },
            fontSize: { xs: '1.25rem', sm: '1.5rem' },
          }}
        >
          Available Reports
        </Typography>

        {/* Single Column Layout */}
        <Stack spacing={{ xs: 2, sm: 2.5, md: 3 }}>
          {reportTypes.map((report) => (
            <Card
              key={report.id}
              elevation={2}
              sx={{
                transition: 'transform 0.2s, box-shadow 0.2s',
                '&:hover': {
                  transform: 'translateY(-2px)',
                  boxShadow: 4,
                },
              }}
            >
              <CardContent sx={{ p: { xs: 2, sm: 2.5, md: 3 } }}>
                <Stack
                  direction={{ xs: 'column', sm: 'row' }}
                  alignItems={{ xs: 'flex-start', sm: 'center' }}
                  spacing={{ xs: 1.5, sm: 2 }}
                  sx={{ mb: 2 }}
                >
                  <Paper
                    elevation={0}
                    sx={{
                      p: { xs: 1, sm: 1.5 },
                      borderRadius: 2,
                      bgcolor: 'action.hover',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                    }}
                  >
                    {report.icon}
                  </Paper>

                  <Stack sx={{ flexGrow: 1, width: '100%' }} spacing={1}>
                    <Stack
                      direction={{ xs: 'column', sm: 'row' }}
                      alignItems={{ xs: 'flex-start', sm: 'center' }}
                      justifyContent="space-between"
                      spacing={1}
                    >
                      <Typography
                        variant="h6"
                        fontWeight={600}
                        sx={{ fontSize: { xs: '1rem', sm: '1.15rem', md: '1.25rem' } }}
                      >
                        {report.title}
                      </Typography>
                      <Chip
                        label={report.category}
                        size="small"
                        color={getCategoryColor(report.category) as any}
                        sx={{ fontSize: { xs: '0.7rem', sm: '0.75rem' } }}
                      />
                    </Stack>

                    <Typography
                      variant="body2"
                      color="textSecondary"
                      sx={{
                        fontSize: { xs: '0.813rem', sm: '0.875rem' },
                        lineHeight: 1.6,
                      }}
                    >
                      {report.description}
                    </Typography>

                    <Stack
                      direction={{ xs: 'column', sm: 'row' }}
                      justifyContent="space-between"
                      alignItems={{ xs: 'flex-start', sm: 'center' }}
                      spacing={{ xs: 1, sm: 2 }}
                    >
                      <Stack direction="row" alignItems="center" spacing={0.5}>
                        <Timer fontSize="small" sx={{ fontSize: { xs: 14, sm: 16 } }} />
                        <Typography
                          variant="caption"
                          color="textSecondary"
                          sx={{ fontSize: { xs: '0.75rem', sm: '0.813rem' } }}
                        >
                          {report.estimatedTime}
                        </Typography>
                      </Stack>
                      <Typography
                        variant="caption"
                        color="textSecondary"
                        sx={{ fontSize: { xs: '0.75rem', sm: '0.813rem' } }}
                      >
                        {report.dataPoints} data points
                      </Typography>
                    </Stack>
                  </Stack>
                </Stack>
              </CardContent>

              <CardActions sx={{ p: { xs: 2, sm: 2.5, md: 3 }, pt: 0 }}>
                <Stack
                  direction={{ xs: 'column', sm: 'row' }}
                  spacing={{ xs: 1, sm: 2 }}
                  sx={{ width: '100%' }}
                >
                  <Button
                    variant="contained"
                    fullWidth
                    startIcon={<PictureAsPdf />}
                    onClick={() => handleExportReport(report.id, 'pdf')}
                    disabled={selectedReport === report.id && exportType === 'pdf'}
                    sx={{
                      py: { xs: 1, sm: 1.25 },
                      fontSize: { xs: '0.875rem', sm: '0.938rem' },
                    }}
                  >
                    {selectedReport === report.id && exportType === 'pdf'
                      ? 'Exporting...'
                      : 'Export to PDF'}
                  </Button>
                  <Button
                    variant="outlined"
                    fullWidth
                    startIcon={<TableChart />}
                    onClick={() => handleExportReport(report.id, 'excel')}
                    disabled={selectedReport === report.id && exportType === 'excel'}
                    sx={{
                      py: { xs: 1, sm: 1.25 },
                      fontSize: { xs: '0.875rem', sm: '0.938rem' },
                    }}
                  >
                    {selectedReport === report.id && exportType === 'excel'
                      ? 'Exporting...'
                      : 'Export to Excel'}
                  </Button>
                </Stack>
              </CardActions>
            </Card>
          ))}
        </Stack>

        {/* Footer Info */}
        <Paper
          elevation={0}
          sx={{
            mt: { xs: 3, sm: 4 },
            p: { xs: 2, sm: 2.5, md: 3 },
            bgcolor: 'grey.50',
            borderRadius: 2,
            border: 1,
            borderColor: 'grey.200',
          }}
        >
          <Typography
            variant="body2"
            color="textSecondary"
            align="center"
            sx={{ fontSize: { xs: '0.75rem', sm: '0.875rem' } }}
          >
            Reports are generated based on current task data ({totalTasks} tasks, {uniqueProjects}{' '}
            projects, {uniqueDepartments} departments). All data is current as of {currentDate}.
          </Typography>
        </Paper>
      </Container>
    </div>
  );
}
